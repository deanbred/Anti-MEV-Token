{
  "language": "Solidity",
  "sources": {
    "contracts/GM.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes calldata) {\n    return msg.data;\n  }\n}\n\ncontract Ownable is Context {\n  address private _owner;\n  address private _previousOwner;\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  constructor() {\n    address msgSender = _msgSender();\n    _owner = msgSender;\n    emit OwnershipTransferred(address(0), msgSender);\n  }\n\n  function owner() public view returns (address) {\n    return _owner;\n  }\n\n  modifier onlyOwner() {\n    require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  function renounceOwnership() public virtual onlyOwner {\n    emit OwnershipTransferred(_owner, address(0));\n    _owner = address(0);\n  }\n\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n  }\n}\n\nlibrary SafeMath {\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, \"SafeMath: subtraction overflow\");\n  }\n\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n    return c;\n  }\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, \"SafeMath: division by zero\");\n  }\n\n  function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b > 0, errorMessage);\n    uint256 c = a / b;\n    return c;\n  }\n}\n\ninterface IERC20 {\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address to, uint256 amount) external returns (bool);\n\n  function allowance(\n    address owner,\n    address spender\n  ) external view returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) external returns (bool);\n}\n\ninterface IERC20Metadata is IERC20 {\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n}\n\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n  mapping(address => uint256) private _balances;\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  uint256 private _totalSupply;\n  string private _name;\n  string private _symbol;\n\n  constructor(string memory name_, string memory symbol_) {\n    _name = name_;\n    _symbol = symbol_;\n  }\n\n  function name() public view virtual override returns (string memory) {\n    return _name;\n  }\n\n  function symbol() public view virtual override returns (string memory) {\n    return _symbol;\n  }\n\n  function decimals() public view virtual override returns (uint8) {\n    return 18;\n  }\n\n  function totalSupply() public view virtual override returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(\n    address account\n  ) public view virtual override returns (uint256) {\n    return _balances[account];\n  }\n\n  function transfer(\n    address to,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    address owner = _msgSender();\n    _transfer(owner, to, amount);\n    return true;\n  }\n\n  function allowance(\n    address owner,\n    address spender\n  ) public view virtual override returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n  function approve(\n    address spender,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    address owner = _msgSender();\n    _approve(owner, spender, amount);\n    return true;\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    address spender = _msgSender();\n    _spendAllowance(from, spender, amount);\n    _transfer(from, to, amount);\n    return true;\n  }\n\n  function increaseAllowance(\n    address spender,\n    uint256 addedValue\n  ) public virtual returns (bool) {\n    address owner = _msgSender();\n    _approve(owner, spender, allowance(owner, spender) + addedValue);\n    return true;\n  }\n\n  function decreaseAllowance(\n    address spender,\n    uint256 subtractedValue\n  ) public virtual returns (bool) {\n    address owner = _msgSender();\n    uint256 currentAllowance = allowance(owner, spender);\n    require(\n      currentAllowance >= subtractedValue,\n      \"ERC20: decreased allowance below zero\"\n    );\n    unchecked {\n      _approve(owner, spender, currentAllowance - subtractedValue);\n    }\n\n    return true;\n  }\n\n  function _transfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {\n    require(from != address(0), \"ERC20: transfer from the zero address\");\n    require(to != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(from, to, amount);\n\n    uint256 fromBalance = _balances[from];\n    require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n    unchecked {\n      _balances[from] = fromBalance - amount;\n      _balances[to] += amount;\n    }\n\n    emit Transfer(from, to, amount);\n\n    _afterTokenTransfer(from, to, amount);\n  }\n\n  function _mint(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: mint to the zero address\");\n\n    _beforeTokenTransfer(address(0), account, amount);\n\n    _totalSupply += amount;\n    unchecked {\n      _balances[account] += amount;\n    }\n    emit Transfer(address(0), account, amount);\n\n    _afterTokenTransfer(address(0), account, amount);\n  }\n\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: burn from the zero address\");\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    uint256 accountBalance = _balances[account];\n    require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n    unchecked {\n      _balances[account] = accountBalance - amount;\n      _totalSupply -= amount;\n    }\n\n    emit Transfer(account, address(0), amount);\n\n    _afterTokenTransfer(account, address(0), amount);\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  function _spendAllowance(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    uint256 currentAllowance = allowance(owner, spender);\n    if (currentAllowance != type(uint256).max) {\n      require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n      unchecked {\n        _approve(owner, spender, currentAllowance - amount);\n      }\n    }\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n\n  function _afterTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n}\n\ninterface IUniswapV2Pair {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external pure returns (string memory);\n\n  function symbol() external pure returns (string memory);\n\n  function decimals() external pure returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(\n    address owner,\n    address spender\n  ) external view returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n  function nonces(address owner) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n  function factory() external view returns (address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves()\n    external\n    view\n    returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function kLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  ) external;\n\n  function skim(address to) external;\n\n  function sync() external;\n\n  function initialize(address, address) external;\n}\n\ninterface IUniswapV2Router01 {\n  function factory() external pure returns (address);\n\n  function WETH() external pure returns (address);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    payable\n    returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETH(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure returns (uint256 amountB);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountOut);\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountIn);\n\n  function getAmountsOut(\n    uint256 amountIn,\n    address[] calldata path\n  ) external view returns (uint256[] memory amounts);\n\n  function getAmountsIn(\n    uint256 amountOut,\n    address[] calldata path\n  ) external view returns (uint256[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountETH);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external payable;\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function WETH() external pure override returns (address);\n}\n\ninterface IUniswapV2Factory {\n  event PairCreated(\n    address indexed token0,\n    address indexed token1,\n    address pair,\n    uint256\n  );\n\n  function feeTo() external view returns (address);\n\n  function feeToSetter() external view returns (address);\n\n  function getPair(\n    address tokenA,\n    address tokenB\n  ) external view returns (address pair);\n\n  function allPairs(uint256) external view returns (address pair);\n\n  function allPairsLength() external view returns (uint256);\n\n  function createPair(\n    address tokenA,\n    address tokenB\n  ) external returns (address pair);\n\n  function setFeeTo(address) external;\n\n  function setFeeToSetter(address) external;\n}\n\ncontract TSUKA is ERC20, Ownable {\n  using SafeMath for uint256;\n\n  IUniswapV2Router02 public uniswapV2Router;\n  address public uniswapV2Pair;\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  uint256 private constant _supply = 777777777 * 1e18;\n  uint256 public _maxTxAmount = 777777777 * 1e18;\n  uint256 public _maxWalletSize = 777777777 * 1e18;\n  uint256 private _buyTax = 4;\n  uint256 private _sellTax = 3;\n  address payable private _teamWallet;\n  bool public _tradingOpen = true;\n  mapping(address => bool) public bots;\n\n  constructor(uint256 initialSupply) ERC20(\"GMUSSY\", \"GMUSSY\") {\n    _mint(msg.sender, initialSupply);\n    _teamWallet = payable(0x8ee9B41620d01dAF068019fEE95D3aC855648B50);\n\n    IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(\n      0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n    );\n    uniswapV2Router = _uniswapV2Router;\n    uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(\n      address(this),\n      _uniswapV2Router.WETH()\n    );\n  }\n\n  function transfer(\n    address recipient,\n    uint256 amount\n  ) public override returns (bool) {\n    _transfer(_msgSender(), recipient, amount);\n    return true;\n  }\n\n  function allowance(\n    address owner,\n    address spender\n  ) public view override returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n  function approve(\n    address spender,\n    uint256 amount\n  ) public override returns (bool) {\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(\n      sender,\n      _msgSender(),\n      _allowances[sender][_msgSender()].sub(\n        amount,\n        \"ERC20: transfer amount exceeds allowance\"\n      )\n    );\n    return true;\n  }\n\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) internal override {\n    uint256 tax = 0;\n    require(_tradingOpen == true);\n    require(\n      !bots[sender] && !bots[recipient],\n      \"TOKEN: Your account is blacklisted!\"\n    );\n    require(amount <= _maxTxAmount, \"TOKEN: Max Transaction Limit\");\n\n    if (recipient != uniswapV2Pair) {\n      require(\n        balanceOf(recipient) + amount < _maxWalletSize,\n        \"TOKEN: Balance exceeds wallet size!\"\n      );\n    }\n\n    if (sender == uniswapV2Pair) {\n      tax = amount.mul(_buyTax).div(100);\n      super._transfer(sender, address(this), tax);\n      super._transfer(address(this), uniswapV2Pair, tax);\n    } else if (recipient == uniswapV2Pair) {\n      tax = amount.mul(_sellTax).div(100);\n      super._transfer(sender, _teamWallet, tax);\n    } else if (\n      sender == owner() ||\n      recipient == owner() ||\n      sender == _teamWallet ||\n      recipient == _teamWallet\n    ) {\n      super._transfer(sender, recipient, amount);\n    }\n\n    super._transfer(sender, recipient, amount - tax);\n  }\n\n  function getUniswapV2Pair() public view returns (address) {\n    return uniswapV2Pair;\n  }\n\n  function setUniswapV2Pair(address newPair) public onlyOwner {\n    uniswapV2Pair = newPair;\n  }\n\n  function setTrading(bool tradingOpen) public onlyOwner {\n    _tradingOpen = tradingOpen;\n  }\n\n  function swapTokensForEth(uint256 tokenAmount) private {\n    address[] memory path = new address[](2);\n    path[0] = address(this);\n    path[1] = uniswapV2Router.WETH();\n    _approve(address(this), address(uniswapV2Router), tokenAmount);\n    uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n      tokenAmount,\n      0,\n      path,\n      address(this),\n      block.timestamp\n    );\n  }\n\n  function sendETHToFee(uint256 amount) private {\n    _teamWallet.transfer(amount);\n  }\n\n  function blockBots(address[] memory bots_) public onlyOwner {\n    for (uint256 i = 0; i < bots_.length; i++) {\n      bots[bots_[i]] = true;\n    }\n  }\n\n  function setMaxTxnAmount(uint256 maxTxAmount) public onlyOwner {\n    _maxTxAmount = maxTxAmount;\n  }\n\n  function setMaxWalletSize(uint256 maxWalletSize) public onlyOwner {\n    _maxWalletSize = maxWalletSize;\n  }\n\n  function setBuyTax(uint256 buyTax) public onlyOwner {\n    _buyTax = buyTax;\n  }\n\n  function setSellTax(uint256 sellTax) public onlyOwner {\n    _sellTax = sellTax;\n  }\n\n  function setTeamWallet(address teamWallet) private onlyOwner {\n    _teamWallet = payable(teamWallet);\n  }\n}\n"
    },
    "contracts/GMUSSY.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address) {\n    return msg.sender;\n  }\n}\n\ninterface IERC20 {\n  function totalSupply() external view returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  function allowance(\n    address owner,\n    address spender\n  ) external view returns (uint256);\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract Ownable is Context {\n  address private _owner;\n  address private _previousOwner;\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  constructor() {\n    address msgSender = _msgSender();\n    _owner = msgSender;\n    emit OwnershipTransferred(address(0), msgSender);\n  }\n\n  function owner() public view returns (address) {\n    return _owner;\n  }\n\n  modifier onlyOwner() {\n    require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  function renounceOwnership() public virtual onlyOwner {\n    emit OwnershipTransferred(_owner, address(0));\n    _owner = address(0);\n  }\n\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n  }\n}\n\nlibrary SafeMath {\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, \"SafeMath: subtraction overflow\");\n  }\n\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n    return c;\n  }\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, \"SafeMath: division by zero\");\n  }\n\n  function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b > 0, errorMessage);\n    uint256 c = a / b;\n    return c;\n  }\n}\n\ninterface IUniswapV2Factory {\n  function createPair(\n    address tokenA,\n    address tokenB\n  ) external returns (address pair);\n}\n\ninterface IUniswapV2Router02 {\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function factory() external pure returns (address);\n\n  function WETH() external pure returns (address);\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    payable\n    returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\n}\n\ncontract GMUSSY is Context, IERC20, Ownable {\n  using SafeMath for uint256;\n\n  string private constant _name = \"GMUSSY\";\n  string private constant _symbol = \"GMUSSY\";\n  uint8 private constant _decimals = 18;\n\n  mapping(address => uint256) private _rOwned;\n  mapping(address => uint256) private _tOwned;\n  mapping(address => mapping(address => uint256)) private _allowances;\n  mapping(address => bool) private _isExcludedFromFee;\n\n  uint256 private constant MAX = ~uint256(0);\n  uint256 private constant _tTotal = 777777777 * 10 ** 18;\n  uint256 private _rTotal = (MAX - (MAX % _tTotal));\n  uint256 private _tFeeTotal;\n  uint256 private _redisFeeOnBuy = 0;\n  uint256 private _taxFeeOnBuy = 3;\n  uint256 private _redisFeeOnSell = 0;\n  uint256 private _taxFeeOnSell = 3;\n\n  //Original Fee\n  uint256 private _redisFee = _redisFeeOnSell;\n  uint256 private _taxFee = _taxFeeOnSell;\n\n  uint256 private _previousredisFee = _redisFee;\n  uint256 private _previoustaxFee = _taxFee;\n\n  mapping(address => bool) public bots;\n  mapping(address => uint256) public _buyMap;\n  address payable private _developmentAddress =\n    payable(0x8ee9B41620d01dAF068019fEE95D3aC855648B50);\n  address payable private _marketingAddress =\n    payable(0x8ee9B41620d01dAF068019fEE95D3aC855648B50);\n\n  IUniswapV2Router02 public uniswapV2Router;\n  address public uniswapV2Pair;\n\n  bool private tradingOpen = true;\n  bool private inSwap = false;\n  bool private swapEnabled = true;\n\n  uint256 public _maxTxAmount = 7777777 * 10 ** 18;\n  uint256 public _maxWalletSize = 7777777 * 10 ** 18;\n  uint256 public _swapTokensAtAmount = 5000 * 10 ** 18;\n\n  event MaxTxAmountUpdated(uint256 _maxTxAmount);\n  modifier lockTheSwap() {\n    inSwap = true;\n    _;\n    inSwap = false;\n  }\n\n  constructor() {\n    _rOwned[_msgSender()] = _rTotal;\n\n    IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(\n      0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n    ); //\n    uniswapV2Router = _uniswapV2Router;\n    uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(\n      address(this),\n      _uniswapV2Router.WETH()\n    );\n\n    _isExcludedFromFee[owner()] = true;\n    _isExcludedFromFee[address(this)] = true;\n    _isExcludedFromFee[_developmentAddress] = true;\n    _isExcludedFromFee[_marketingAddress] = true;\n\n    emit Transfer(address(0), _msgSender(), _tTotal);\n  }\n\n  function name() public pure returns (string memory) {\n    return _name;\n  }\n\n  function symbol() public pure returns (string memory) {\n    return _symbol;\n  }\n\n  function decimals() public pure returns (uint8) {\n    return _decimals;\n  }\n\n  function totalSupply() public pure override returns (uint256) {\n    return _tTotal;\n  }\n\n  function balanceOf(address account) public view override returns (uint256) {\n    return tokenFromReflection(_rOwned[account]);\n  }\n\n  function transfer(\n    address recipient,\n    uint256 amount\n  ) public override returns (bool) {\n    _transfer(_msgSender(), recipient, amount);\n    return true;\n  }\n\n  function allowance(\n    address owner,\n    address spender\n  ) public view override returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n  function approve(\n    address spender,\n    uint256 amount\n  ) public override returns (bool) {\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(\n      sender,\n      _msgSender(),\n      _allowances[sender][_msgSender()].sub(\n        amount,\n        \"ERC20: transfer amount exceeds allowance\"\n      )\n    );\n    return true;\n  }\n\n  function tokenFromReflection(uint256 rAmount) private view returns (uint256) {\n    require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n    uint256 currentRate = _getRate();\n    return rAmount.div(currentRate);\n  }\n\n  function removeAllFee() private {\n    if (_redisFee == 0 && _taxFee == 0) return;\n\n    _previousredisFee = _redisFee;\n    _previoustaxFee = _taxFee;\n\n    _redisFee = 0;\n    _taxFee = 0;\n  }\n\n  function restoreAllFee() private {\n    _redisFee = _previousredisFee;\n    _taxFee = _previoustaxFee;\n  }\n\n  function _approve(address owner, address spender, uint256 amount) private {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  function _transfer(address from, address to, uint256 amount) private {\n    require(from != address(0), \"ERC20: transfer from the zero address\");\n    require(to != address(0), \"ERC20: transfer to the zero address\");\n    require(amount > 0, \"Transfer amount must be greater than zero\");\n\n    if (from != owner() && to != owner()) {\n      //Trade start check\n      if (!tradingOpen) {\n        require(\n          from == owner(),\n          \"TOKEN: This account cannot send tokens until trading is enabled\"\n        );\n      }\n\n      require(amount <= _maxTxAmount, \"TOKEN: Max Transaction Limit\");\n      require(!bots[from] && !bots[to], \"TOKEN: Your account is blacklisted!\");\n\n      if (to != uniswapV2Pair) {\n        require(\n          balanceOf(to) + amount < _maxWalletSize,\n          \"TOKEN: Balance exceeds wallet size!\"\n        );\n      }\n\n      uint256 contractTokenBalance = balanceOf(address(this));\n      bool canSwap = contractTokenBalance >= _swapTokensAtAmount;\n\n      if (contractTokenBalance >= _maxTxAmount) {\n        contractTokenBalance = _maxTxAmount;\n      }\n\n      if (\n        canSwap &&\n        !inSwap &&\n        from != uniswapV2Pair &&\n        swapEnabled &&\n        !_isExcludedFromFee[from] &&\n        !_isExcludedFromFee[to]\n      ) {\n        swapTokensForEth(contractTokenBalance);\n        uint256 contractETHBalance = address(this).balance;\n        if (contractETHBalance > 0) {\n          sendETHToFee(address(this).balance);\n        }\n      }\n    }\n\n    bool takeFee = true;\n\n    //Transfer Tokens\n    if (\n      (_isExcludedFromFee[from] || _isExcludedFromFee[to]) ||\n      (from != uniswapV2Pair && to != uniswapV2Pair)\n    ) {\n      takeFee = false;\n    } else {\n      //Set Fee for Buys\n      if (from == uniswapV2Pair && to != address(uniswapV2Router)) {\n        _redisFee = _redisFeeOnBuy;\n        _taxFee = _taxFeeOnBuy;\n      }\n\n      //Set Fee for Sells\n      if (to == uniswapV2Pair && from != address(uniswapV2Router)) {\n        _redisFee = _redisFeeOnSell;\n        _taxFee = _taxFeeOnSell;\n      }\n    }\n\n    _tokenTransfer(from, to, amount, takeFee);\n  }\n\n  function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\n    address[] memory path = new address[](2);\n    path[0] = address(this);\n    path[1] = uniswapV2Router.WETH();\n    _approve(address(this), address(uniswapV2Router), tokenAmount);\n    uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n      tokenAmount,\n      0,\n      path,\n      address(this),\n      block.timestamp\n    );\n  }\n\n  function sendETHToFee(uint256 amount) private {\n    _marketingAddress.transfer(amount);\n  }\n\n  function setTrading(bool _tradingOpen) public onlyOwner {\n    tradingOpen = _tradingOpen;\n  }\n\n  function manualswap() external {\n    require(\n      _msgSender() == _developmentAddress || _msgSender() == _marketingAddress\n    );\n    uint256 contractBalance = balanceOf(address(this));\n    swapTokensForEth(contractBalance);\n  }\n\n  function manualsend() external {\n    require(\n      _msgSender() == _developmentAddress || _msgSender() == _marketingAddress\n    );\n    uint256 contractETHBalance = address(this).balance;\n    sendETHToFee(contractETHBalance);\n  }\n\n  function blockBots(address[] memory bots_) public onlyOwner {\n    for (uint256 i = 0; i < bots_.length; i++) {\n      bots[bots_[i]] = true;\n    }\n  }\n\n  function unblockBot(address notbot) public onlyOwner {\n    bots[notbot] = false;\n  }\n\n  function _tokenTransfer(\n    address sender,\n    address recipient,\n    uint256 amount,\n    bool takeFee\n  ) private {\n    if (!takeFee) removeAllFee();\n    _transferStandard(sender, recipient, amount);\n    if (!takeFee) restoreAllFee();\n  }\n\n  function _transferStandard(\n    address sender,\n    address recipient,\n    uint256 tAmount\n  ) private {\n    (\n      uint256 rAmount,\n      uint256 rTransferAmount,\n      uint256 rFee,\n      uint256 tTransferAmount,\n      uint256 tFee,\n      uint256 tTeam\n    ) = _getValues(tAmount);\n    _rOwned[sender] = _rOwned[sender].sub(rAmount);\n    _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n    _takeTeam(tTeam);\n    _reflectFee(rFee, tFee);\n    emit Transfer(sender, recipient, tTransferAmount);\n  }\n\n  function _takeTeam(uint256 tTeam) private {\n    uint256 currentRate = _getRate();\n    uint256 rTeam = tTeam.mul(currentRate);\n    _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\n  }\n\n  function _reflectFee(uint256 rFee, uint256 tFee) private {\n    _rTotal = _rTotal.sub(rFee);\n    _tFeeTotal = _tFeeTotal.add(tFee);\n  }\n\n  receive() external payable {}\n\n  function _getValues(\n    uint256 tAmount\n  )\n    private\n    view\n    returns (uint256, uint256, uint256, uint256, uint256, uint256)\n  {\n    (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getTValues(\n      tAmount,\n      _redisFee,\n      _taxFee\n    );\n    uint256 currentRate = _getRate();\n    (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(\n      tAmount,\n      tFee,\n      tTeam,\n      currentRate\n    );\n    return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\n  }\n\n  function _getTValues(\n    uint256 tAmount,\n    uint256 redisFee,\n    uint256 taxFee\n  ) private pure returns (uint256, uint256, uint256) {\n    uint256 tFee = tAmount.mul(redisFee).div(100);\n    uint256 tTeam = tAmount.mul(taxFee).div(100);\n    uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\n    return (tTransferAmount, tFee, tTeam);\n  }\n\n  function _getRValues(\n    uint256 tAmount,\n    uint256 tFee,\n    uint256 tTeam,\n    uint256 currentRate\n  ) private pure returns (uint256, uint256, uint256) {\n    uint256 rAmount = tAmount.mul(currentRate);\n    uint256 rFee = tFee.mul(currentRate);\n    uint256 rTeam = tTeam.mul(currentRate);\n    uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\n    return (rAmount, rTransferAmount, rFee);\n  }\n\n  function _getRate() private view returns (uint256) {\n    (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n    return rSupply.div(tSupply);\n  }\n\n  function _getCurrentSupply() private view returns (uint256, uint256) {\n    uint256 rSupply = _rTotal;\n    uint256 tSupply = _tTotal;\n    if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n    return (rSupply, tSupply);\n  }\n\n  function setFee(\n    uint256 redisFeeOnBuy,\n    uint256 redisFeeOnSell,\n    uint256 taxFeeOnBuy,\n    uint256 taxFeeOnSell\n  ) public onlyOwner {\n    _redisFeeOnBuy = redisFeeOnBuy;\n    _redisFeeOnSell = redisFeeOnSell;\n    _taxFeeOnBuy = taxFeeOnBuy;\n    _taxFeeOnSell = taxFeeOnSell;\n  }\n\n  function setMinSwapTokensThreshold(\n    uint256 swapTokensAtAmount\n  ) public onlyOwner {\n    _swapTokensAtAmount = swapTokensAtAmount;\n  }\n\n  function toggleSwap(bool _swapEnabled) public onlyOwner {\n    swapEnabled = _swapEnabled;\n  }\n\n  function setMaxTxnAmount(uint256 maxTxAmount) public onlyOwner {\n    _maxTxAmount = maxTxAmount;\n  }\n\n  function setMaxWalletSize(uint256 maxWalletSize) public onlyOwner {\n    _maxWalletSize = maxWalletSize;\n  }\n\n  function excludeMultipleAccountsFromFees(\n    address[] calldata accounts,\n    bool excluded\n  ) public onlyOwner {\n    for (uint256 i = 0; i < accounts.length; i++) {\n      _isExcludedFromFee[accounts[i]] = excluded;\n    }\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}