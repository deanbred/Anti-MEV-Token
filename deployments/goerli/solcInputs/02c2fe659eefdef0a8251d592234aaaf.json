{
  "language": "Solidity",
  "sources": {
    "contracts/AntiMEV.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes calldata) {\n    return msg.data;\n  }\n}\n\nabstract contract Ownable is Context {\n  address private _owner;\n\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  constructor() {\n    _transferOwnership(_msgSender());\n  }\n\n  function owner() public view virtual returns (address) {\n    return _owner;\n  }\n\n  modifier onlyOwner() {\n    require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  function renounceOwnership() public virtual onlyOwner {\n    _transferOwnership(address(0));\n  }\n\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n    _transferOwnership(newOwner);\n  }\n\n  function _transferOwnership(address newOwner) internal virtual {\n    address oldOwner = _owner;\n    _owner = newOwner;\n    emit OwnershipTransferred(oldOwner, newOwner);\n  }\n}\n\ninterface IERC20 {\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address to, uint256 amount) external returns (bool);\n\n  function allowance(\n    address owner,\n    address spender\n  ) external view returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) external returns (bool);\n}\n\ninterface IERC20Metadata is IERC20 {\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the symbol of the token.\n   */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the decimals places of the token.\n   */\n  function decimals() external view returns (uint8);\n}\n\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n  mapping(address => uint256) private _balances;\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  string private _name;\n  string private _symbol;\n  uint256 private _totalSupply;\n\n  constructor(string memory name_, string memory symbol_) {\n    _name = name_;\n    _symbol = symbol_;\n  }\n\n  function name() public view virtual override returns (string memory) {\n    return _name;\n  }\n\n  function symbol() public view virtual override returns (string memory) {\n    return _symbol;\n  }\n\n  function decimals() public view virtual override returns (uint8) {\n    return 18;\n  }\n\n  function totalSupply() public view virtual override returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(\n    address account\n  ) public view virtual override returns (uint256) {\n    return _balances[account];\n  }\n\n  function transfer(\n    address recipient,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    _transfer(_msgSender(), recipient, amount);\n    return true;\n  }\n\n  function allowance(\n    address owner,\n    address spender\n  ) public view virtual override returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n  function approve(\n    address spender,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    _transfer(sender, recipient, amount);\n\n    uint256 currentAllowance = _allowances[sender][_msgSender()];\n    require(\n      currentAllowance >= amount,\n      \"ERC20: transfer amount exceeds allowance\"\n    );\n    unchecked {\n      _approve(sender, _msgSender(), currentAllowance - amount);\n    }\n\n    return true;\n  }\n\n  function increaseAllowance(\n    address spender,\n    uint256 addedValue\n  ) public virtual returns (bool) {\n    _approve(\n      _msgSender(),\n      spender,\n      _allowances[_msgSender()][spender] + addedValue\n    );\n    return true;\n  }\n\n  function decreaseAllowance(\n    address spender,\n    uint256 subtractedValue\n  ) public virtual returns (bool) {\n    uint256 currentAllowance = _allowances[_msgSender()][spender];\n    require(\n      currentAllowance >= subtractedValue,\n      \"ERC20: decreased allowance below zero\"\n    );\n    unchecked {\n      _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n    }\n\n    return true;\n  }\n\n  /**\n   * @dev Moves `amount` of tokens from `sender` to `recipient`.\n   *\n   * This internal function is equivalent to {transfer}, and can be used to\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\n   *\n   * Emits a {Transfer} event.\n   *\n   * Requirements:\n   *\n   * - `sender` cannot be the zero address.\n   * - `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   */\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) internal virtual {\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(sender, recipient, amount);\n\n    uint256 senderBalance = _balances[sender];\n    require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n    unchecked {\n      _balances[sender] = senderBalance - amount;\n    }\n    _balances[recipient] += amount;\n\n    emit Transfer(sender, recipient, amount);\n\n    _afterTokenTransfer(sender, recipient, amount);\n  }\n\n  function _mint(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: mint to the zero address\");\n\n    _beforeTokenTransfer(address(0), account, amount);\n\n    _totalSupply += amount;\n    _balances[account] += amount;\n    emit Transfer(address(0), account, amount);\n\n    _afterTokenTransfer(address(0), account, amount);\n  }\n\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: burn from the zero address\");\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    uint256 accountBalance = _balances[account];\n    require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n    unchecked {\n      _balances[account] = accountBalance - amount;\n    }\n    _totalSupply -= amount;\n\n    emit Transfer(account, address(0), amount);\n\n    _afterTokenTransfer(account, address(0), amount);\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n\n  function _afterTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n}\n\ncontract AntiMEV is ERC20, Ownable {\n  bool public enabled = true;\n  uint256 public maxWallet = 1123581321 * 1e16; // 1% of supply\n  uint16 public blockDelay = 3;\n  address public uniswapV2Pair;\n\n  mapping(address => bool) public bots;\n  mapping(address => uint256) private lastTxBlock;\n\n  constructor(uint256 _totalSupply) ERC20(\"AntiMEV\", \"aMEV\") {\n    _mint(msg.sender, _totalSupply);\n  }\n\n  function setVars(\n    bool _enabled,\n    uint256 _maxWallet,\n    uint16 _blockDelay,\n    address _uniswapV2Pair\n  ) external onlyOwner {\n    enabled = _enabled;\n    maxWallet = _maxWallet;\n    blockDelay = _blockDelay;\n    uniswapV2Pair = _uniswapV2Pair;\n  }\n\n  function setBots(\n    address[] memory _address,\n    bool[] memory _isBot\n  ) external onlyOwner {\n    for (uint256 i = 0; i < _address.length; i++) {\n      require(_address[i] != address(this) && _address[i] != owner());\n      bots[_address[i]] = _isBot[i];\n    }\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual override {\n    require(enabled);\n\n    // check if known MEV bot\n    require(!bots[to] && !bots[from], \"MEV BOT!\");\n\n    // check if trading is live\n    if (uniswapV2Pair == address(0)) {\n      require(from == owner() || to == owner(), \"PAIR NOT SET!\");\n      return;\n    }\n\n    // enforce max wallet size\n    if (enabled && from == uniswapV2Pair) {\n      require(super.balanceOf(to) + amount <= maxWallet, \"MAX WALLET!\");\n    }\n  }\n\n  function transfer(\n    address recipient,\n    uint256 amount\n  ) public override returns (bool) {\n    require(\n      block.number > lastTxBlock[msg.sender] + blockDelay,\n      \"AntiMEVToken: Cannot transfer twice in the same block\"\n    );\n    lastTxBlock[msg.sender] = block.number;\n    return super.transfer(recipient, amount);\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public override returns (bool) {\n    require(\n      block.number > lastTxBlock[sender] + blockDelay,\n      \"AntiMEVToken: Cannot transfer twice in the same block\"\n    );\n    lastTxBlock[sender] = block.number;\n    return super.transferFrom(sender, recipient, amount);\n  }\n\n  function burn(uint256 value) external onlyOwner {\n    _burn(msg.sender, value);\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}